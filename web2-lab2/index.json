[
  {
    "content": " Rozszerz swoją implementację o moliwość sortowania uczestników po loginie. Dodatkowo chcemy mieć możliwość wyboru kolejności sortowania ASC lub DESC wg przykładów poniżej:\nSortowanie listy wyników po loginie w kolejności malejącej http://localhost:8080/participants?sortBy=login\u0026sortOrder=DESC Sortowanie listy wyników po loginie w kolejności rosnącej http://localhost:8080/participants?sortBy=login\u0026sortOrder=ASC Sortowanie listy wyników w domyślnej kolejności (parametr sortOrder nie jest obowiązkowy): http://localhost:8080/participants?sortBy=login Endpoint powinnien być odporny na podawanie błędnych/nie obsługiwanych wartości.\nDodaj parametr filtrowania listy wyników po loginie, zgodnie z poniższymi przykładami:\nhttp://localhost:8080/participants?key=login - pokaże tylko uczestników, które loginy zawierają słowo kluczowe login http://localhost:8080/participants?key=og - pokaże tylko uczestników, które loginy zawierają słowo kluczowe og Skommituj kod i wyślij do swojego repozytorium: Commit \u0026 Push !\nPodpowiedź By zmapować parametr z URI na parametr wywołania funkcji użyj adnotacji @RequestParam. Poniżej przykład: public ResponseEntity\u003c?\u003e someFunction(@RequestParam(value = \"parametr_name\", defaultValue = \"\") String param)\tZadanie obróbki wyników zapytania przekaż do klas odpowiedzialnych za komunikację z bazą danych. ",
    "description": "",
    "tags": null,
    "title": "Dodatkowe funkcje dla uczestników",
    "uri": "/03_participant_advanced/"
  },
  {
    "content": "Analogicznie do endpoint’ów dla uczestników zaimplementuj poniższe endpointy dla spotkań:\nPobieranie listy wszystkich spotkań Pobieranie listy pojedyncznego spotkania Commit \u0026 Push ! Podpowiedź Pamiętaj, że w tym celu musisz dodać nowy kontroller: @RestController @RequestMapping(\"/meetings\") public class MeetingRestController Nie zapomnij również o odpowiednim serwisie: @Autowired MeetingService meetingService; ",
    "description": "",
    "tags": null,
    "title": "Endpointy dla spotkań",
    "uri": "/04_meeting/"
  },
  {
    "content": " Zbuduj aplikację za pomocą Mavena i fazy ‘Package’. Zbudowaną paczkę uruchom z poziomu konsoli: java -jar \u003cpath-to-your-project\u003e/agh-mwo-enroller/target/enroller-0.0.1-SNAPSHOT.jar Powinieneś zobaczyć, że aplikacja się uruchamia. Zakończ działanie aplikacji. Spróbuj wywołać fazę Clean - katalog target powinien zostać usunięty. Przyjrzyj się plikowi Dockerfile. To plik konfiguracyjny, który pozwoli nam uruchomić naszą aplikację w wirtualnym środowisku za pomocą środowiska Docker Docker umożliwia tworzenie, uruchamianie i zarządzanie aplikacjami w kontenerach. Kontenery to izolowane środowiska uruchomieniowe, które pozwalają na pakowanie aplikacji i ich zależności w spójny sposób. Dzięki temu aplikacja może działać w izolowanym środowisku bez konieczności instalacji dodatkowych zależności na maszynie hosta. Docker umożliwia łatwe przenoszenie aplikacji między różnymi środowiskami, co ułatwia zarządzanie wdrażaniem aplikacji oraz zapewnia spójność między różnymi środowiskami, na których aplikacja jest uruchamiana. Dzięki temu Docker jest obecnie szeroko stosowany i znacznie ułatwia zarządzanie infrastrukturą i wdrażanie aplikacji. Dockerfile w projekcie prezentuje przykład wieloetapowych buildów (Multi-stage builds). W pierwszej części pobiera on obraz Linuxowy (dystrybucja Amazon Linux) z zainstalowanym Mavenem po czym następuje budowanie projektu do postaci paczki JAR (mvn package). W drugiej części następujace skopiowanie paczki i jej uruchomienie. Jednocześnie w pliku deklarujemy, że maszyna udostępnia port 8080. Czas na uruchomienie aplikacji na zdalnym serwerze. Spróbujmy wykorzystać darmowe środowisko oferowane przez https://www.back4app.com. Zarejestruj się swoim kontem Github Dodaj nową aplikację, pomiając ankietę (SKIP) Wybierz opcję Containers as a Service Znajdź i wybierz (Select) odpowiednie repozytorium na Githubie - najlepiej dać dostęp tylko do tego repozytorium Podaj nazwę i utwórz aplikację (Create App) Po tym kroku nastąpi pobranie Twojego kodu z repozytorium, pobranie obrazów na podstawie pliku Dockerfile, uruchomienie ich, pobranie zależności Mavena, zbudowanie produktu i uruchomienie aplikacji. Wszystko to zobaczysz w logach, które odświeżane są na żywo. Pożądanym efektem jest komunikat następującej treści: 2023-04-14T23:26:36.552Z # VERIFYING QUEUE... 2023-04-14T23:26:36.577Z # RELEASING DEPLOYMENT... 2023-04-14T23:26:36.630Z # DEPLOYMENT READY Po jego zobaczeniu możesz przejść do swojej aplikacji: Przejdź do Postmana i sprawdź w nim działanie swojej upublicznionej aplikacji. ",
    "description": "",
    "tags": null,
    "title": "Deployment",
    "uri": "/05_deployment/"
  },
  {
    "content": " W tym punkcie chcemy zabezpieczyć endpointy przed niepowołowanym dostępem. Potrafimy już identyfikować użytkowników, czas z tego skorzystać. Dodaj w tym celu kolejną klasę JWTAuthorizationFilter do pakietu security: package com.company.enroller.security; import com.auth0.jwt.JWT; import com.auth0.jwt.JWTVerifier; import com.auth0.jwt.algorithms.Algorithm; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.web.authentication.www.BasicAuthenticationFilter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.ArrayList; public class JWTAuthorizationFilter extends BasicAuthenticationFilter { private static final String HEADER_NAME = \"Authorization\"; private static final String TOKEN_PREFIX = \"Bearer \"; private final JWTVerifier verifier; public JWTAuthorizationFilter(AuthenticationManager authManager, String secret) throws UnsupportedEncodingException { super(authManager); verifier = JWT.require(Algorithm.HMAC256(secret)).acceptExpiresAt(0).build(); } @Override protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { String header = req.getHeader(HEADER_NAME); if (header != null \u0026\u0026 header.startsWith(TOKEN_PREFIX)) { String token = header.substring(TOKEN_PREFIX.length()); Authentication authentication = extractUserFromToken(token); SecurityContextHolder.getContext().setAuthentication(authentication); } chain.doFilter(req, res); } private Authentication extractUserFromToken(String token) { String username = verifier.verify(token).getSubject(); if (username != null) { return new UsernamePasswordAuthenticationToken(username, null, new ArrayList\u003c\u003e()); } return null; } } Zarejestruj ten filtr w konfiguracji zabezpieczeń: .addFilter(new JWTAuthorizationFilter(authenticationManager(), secret)) Skonfiguruj mechanizm zabezpieczeń (klasa WebSecurity) tak, by nie pozwalał na korzystanie z aplikacji bez zalogowania się (poza endpointem wystawiającym token oraz rejestrującym użytkownika): .authorizeRequests() .antMatchers(HttpMethod.POST, \"/participants\").permitAll() .antMatchers(\"/tokens\").permitAll() .antMatchers(\"/**\").authenticated() Sprawdź, czy nadal możesz założyć konto i czy dostęp do /meetings rzeczywiście został zablokowany, jeśli użytkownik nie jest zalogowany. Zalogowanie to pozyskanie tokena, a następnie jego użycie w każdym zapytaniu do endpointa. W tym celu musisz go przesłać w nagłówku zapytania. Możesz to zrobić w Postmanie tak jak na załączonym obrazku: Gotowe! Commit, push, deploy! ",
    "description": "",
    "tags": null,
    "title": "Zabezpieczamy aplikację",
    "uri": "/08_authorization/"
  },
  {
    "content": " Czas zabezpieczyć aplikację. Po pierwsze wysyłamy hasła razem z loginami. I do tego są one w plain-text. Po drugie każdy może wyświetlić zawartość naszej bazy. Na początek zabezpiecz aplikację przed wysyłaniem haseł. Wystarczy dodać odpowiednią adnotację w odpowiednim miejscu :-) @JsonProperty(access = JsonProperty.Access.WRITE_ONLY) Sprawdź efekt działania. Jak? Dodajmy bibliotekę odpowiedzialną za bezpieczeństwo dla frameworka Spring: spring-boot-starter-security. Jak to zrobić? Powinieneś to już wiedzieć ;-) Następnie sprawdź efekt działania. Co zauważyłeś? Czy aplikacja działa? Czas rozbudować ochronę i zacząć szyfrować hasła. Wcześniej jednak musimy być w stanie cokolwiek w aplikacji zrobić, bo obecnie niewiele możemy. W tym celu pakiet Security a w nim klasę WebSecurity odpowiedzialną za kontrolę bezpieczeństwa: package com.company.enroller.security; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; @EnableWebSecurity public class WebSecurity extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable() .authorizeRequests() .anyRequest().permitAll() .and() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); } } Sprawdź teraz efekt działania. Co zauważyłeś? Teraz dodaj funkcję która nam zakoduje/zashasuje hasło do głównej klasy App: @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } A następnie ją wykorzystaj tam gdzie dodajesz nowego użytkownika: String hashedPassword = passwordEncoder.encode(participant.getPassword()); participant.setPassword(hashedPassword); Sprawdź efekt działania. Dodaj nowego użytkowika i zobacz czy jego hasło będzie zaszyfrowane w bazie danych. Zapamiętaj lub zapisz podane hasło! Na koniec: Commit, push, deploy! ",
    "description": "",
    "tags": null,
    "title": "Zabezpieczamy aplikację",
    "uri": "/06_basic_security/"
  },
  {
    "content": " Czas przejść do autentykacji. A może autoryzacji? Czy to jest to samo czy czymś się jednak różni? Info Uwierzytelnianie i autoryzacja to dwa kluczowe procesy bezpieczeństwa informacji, które administratorzy wykorzystują do ochrony systemów i informacji. Uwierzytelnianie weryfikuje tożsamość użytkownika lub usługi, a autoryzacja określa jego prawa dostępu.\nDo weryfikacji tożsamości obecnie najczęściej wykorzystuje się tokeny, a w szczególności tokeny JWT. Tokeny te zawierają komplet informacji o użytkowniku. Serwer nie musi posiadać przetwarzać dodatkowych informacji. Działają więc na zasadzie dowodu tożsamości. Więcej informacji znajdziesz na stronie https://jwt.io. Naszym celem jest więc zaimplementowanie nowego endpointa, który na podstawie przesłanych danych wygeneruje nam odpowiedni token. W tym celu dodaj do projektu bibliotekę dodającą wsparcie dla JWT: java-jwt. Dodaj klasę do pakietu security pozwalającą na ładowanie użytkowników przez system autentykacji Springa: package com.company.enroller.security; import com.company.enroller.model.Participant; import com.company.enroller.persistence.ParticipantService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service; import java.util.Collections; @Service public class ParticipantProvider implements UserDetailsService { @Autowired private ParticipantService participantService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Participant participant = participantService.findByLogin(username); if (participant == null) { throw new UsernameNotFoundException(username); } return new User(participant.getLogin(), participant.getPassword(), Collections.emptyList()); } } W klasie WebSecurity wstrzyknij wymagane zależności i skonfiguruj system autentykacji nadpisując odpowiednią metodę: @Override public void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(participantProvider).passwordEncoder(passwordEncoder); } W katalogu src/main/resources utwórz plik application.properties z konfiguracją aplikacji: security.secret = ThisIsNotSoSecretSoChangeIt security.issuer = https://myenrollerdemo-twoj_login.b4a.run security.token_expiration_in_seconds = 3600 Do pakietu security dodaj nową klasę. Będzie to filtr requestów, który wystawi token JWT gdy klient prześle poprawne dane logowania: package com.company.enroller.security; import com.auth0.jwt.JWT; import com.auth0.jwt.algorithms.Algorithm; import com.company.enroller.model.Participant; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.http.HttpMethod; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.BadCredentialsException; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.AuthenticationException; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter; import org.springframework.security.web.util.matcher.AntPathRequestMatcher; import javax.servlet.FilterChain; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.time.LocalDateTime; import java.time.ZoneId; import java.util.ArrayList; import java.util.Date; public class JWTAuthenticationFilter extends AbstractAuthenticationProcessingFilter { private AuthenticationManager authenticationManager; private final String secret; private final String issuer; private final int tokenExpiration; public JWTAuthenticationFilter(AuthenticationManager authenticationManager, String secret, String issuer, int tokenExpiration) { super(new AntPathRequestMatcher(\"/tokens\", HttpMethod.POST.name())); this.authenticationManager = authenticationManager; this.secret = secret; this.issuer = issuer; this.tokenExpiration = tokenExpiration; } @Override public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res) throws AuthenticationException { try { Participant participant = new ObjectMapper().readValue(req.getInputStream(), Participant.class); Authentication authentication = new UsernamePasswordAuthenticationToken(participant.getLogin(), participant.getPassword(), new ArrayList\u003c\u003e()); return authenticationManager.authenticate(authentication); } catch (IOException e) { throw new BadCredentialsException(\"Invalid login request.\", e); } } @Override protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse res, FilterChain chain, Authentication auth) throws IOException { String login = ((UserDetails) auth.getPrincipal()).getUsername(); LocalDateTime now = LocalDateTime.now(); String token = JWT.create() .withIssuer(issuer) .withSubject(login) .withIssuedAt(Date.from(now.atZone(ZoneId.systemDefault()).toInstant())) .withExpiresAt(Date.from(now.plusSeconds(tokenExpiration).atZone(ZoneId.systemDefault()).toInstant())) .withClaim(\"role\", \"participant\") .sign(Algorithm.HMAC256(secret)); res.getWriter().write(String.format(\"{\\\"token\\\": \\\"%s\\\"}\", token)); } } W klasie WebSecurity w metodzie configure zarejestruj stworzony filtr: .addFilterBefore(new JWTAuthenticationFilter(authenticationManager(), secret, issuer, tokenExpiration), UsernamePasswordAuthenticationFilter.class) Potrzebne wartości wstrzyknij z konfiguracji aplikacji za pomocą adnotacji @Value, na zasadzie: @Value(\"${security.secret}\") String secret; Przetestuj wystawianie tokena za pomocą Postmana. W tym przypomij sobie z poprzedniego kroku dane nowego użytkownika. Następnie wywołaj żądanie utworzenia nowego tokenu podając dane wstawionego użytkownika: curl -s -d '{\"login\":\"janek\", \"password\":\"tajemne\"}' -H \"Content-Type: application/json\" -X POST http://localhost:8080/api/tokens Efektem powinien być otrzymany na wyjściu token. Możesz go zdekodować na znanej już stronie https://jwt.io Sprawdź kiedy token wygaśnie - zdekoduj datę wygaśnięcia np. przy pomocy strony: https://www.epochconverter.com Commit, push, deploy! ",
    "description": "",
    "tags": null,
    "title": "Dodajemy autentykację",
    "uri": "/07_authentication/"
  },
  {
    "content": "Wprowadzenie Witaj ponownie! Dziś nadal budujemy serwis REST dla aplikacji do zarządzania spotkaniami typu meetups\nCelem dzisiejszych zajeć jest:\ndalsze ćwiczenie budowy endpointów poprzez dodanie sortowania oraz nowych endpointów dla spotkań uruchomienie rozwiązania do wdrożenia na zewnętrznych serwerach wzbogacenie projektowanych mikroserwisów o mechanizmy bezpieczeństwa Powodzenia!\nZaczynamy pracę Sforkuj i sklonuj repozytorium: https://github.com/jdajda/agh-mwo-enroller-lab2 Zaimpoortuj projekt w IntelliJ Czekając na zaimportowanie projektu przejrzyj rozwiązanie Pobierz i zainstaluj Postmana Plan zajęć Dodatkowe funkcje dla uczestników Kilka endpointów dla spotkań Deployment Zabezpieczamy aplikację Dodajemy autentykację Dodajemy autoryzację ",
    "description": "",
    "tags": null,
    "title": "Wprowadzenie",
    "uri": "/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  }
]
